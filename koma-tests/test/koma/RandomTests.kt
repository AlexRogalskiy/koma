package koma

import koma.internal.KomaRandom
import koma.internal.getRng
import org.junit.Test

class RandomTests {

    @Test
    fun testReference() {
        // Compare to values generated by the reference implementation of PCG.
        
        val rng = KomaRandom(100, 1000)
        val expected = intArrayOf(1661439714, -1836977776, 1117698072, -1718436217, -1082162739,
                                  -227351909, -998247866, -997876715, 1616470541, 1410786046)
        for (i in 0 until 10)
            assert(rng.nextInt() == expected[i])
    }

    @Test
    fun testIntDistribution() {
        // Check that each bit is equally likely to be a 0 or 1.
        
        val count = 10000
        val bitCounts = IntArray(32)
        val rng = getRng()
        for (i in 1..count) {
            val value = rng.nextInt()
            for (j in 0 until 32)
                if (value and (1 shl j) != 0)
                    bitCounts[j]++
        }
        val tol = 4*sqrt(count/2)
        for (i in 0 until 32) {
            assert(bitCounts[i] >= count/2 - tol)
            assert(bitCounts[i] <= count/2 + tol)
        }
    }

    @Test
    fun testLongDistribution() {
        // Check that each bit is equally likely to be a 0 or 1.
        
        val count = 10000
        val bitCounts = IntArray(64)
        val rng = getRng()
        for (i in 1..count) {
            val value = rng.nextLong()
            for (j in 0 until 64) {
                if (value and (1L shl j) != 0L)
                    bitCounts[j]++
            }
        }
        val tol = 4*sqrt(count/2)
        for (i in 0 until 64) {
            assert(bitCounts[i] >= count/2 - tol)
            assert(bitCounts[i] <= count/2 + tol)
        }
    }
    
    @Test
    fun testBoundedIntDistribution() {
        // Check that each value occurs equally often.

        val count = 10000
        val bins = 10
        val binCounts = IntArray(bins)
        val rng = getRng()
        for (i in 1..count) {
            val value = rng.nextInt(bins)
            assert(value >= 0 && value < bins)
            binCounts[value]++
        }
        val tol = 4*sqrt(count/bins)
        for (i in 0 until bins) {
            assert(binCounts[i] >= count/bins - tol)
            assert(binCounts[i] <= count/bins + tol)
        }
    }
    
    @Test
    fun testBoundedLongDistribution() {
        // Check that each value occurs equally often.

        val count = 10000
        val bins = 10
        val binCounts = IntArray(bins)
        val rng = getRng()
        for (i in 1..count) {
            val value = rng.nextLong(bins.toLong())
            assert(value >= 0 && value < bins)
            binCounts[value.toInt()]++
        }
        val tol = 4*sqrt(count/bins)
        for (i in 0 until bins) {
            assert(binCounts[i] >= count/bins - tol)
            assert(binCounts[i] <= count/bins + tol)
        }
    }

    @Test
    fun testFloatDistribution() {
        // Check that values are uniformly distributed between 0 and 1.

        val count = 10000
        val bins = 10
        val binCounts = IntArray(bins)
        val rng = getRng()
        for (i in 1..count) {
            val value = rng.nextFloat()
            assert(value >= 0.0f && value < 1.0f)
            binCounts[(value*bins).toInt()]++
        }
        val tol = 4*sqrt(count/bins)
        for (i in 0 until bins) {
            assert(binCounts[i] >= count/bins - tol)
            assert(binCounts[i] <= count/bins + tol)
        }
    }

    @Test
    fun testDoubleDistribution() {
        // Check that values are uniformly distributed between 0 and 1.

        val count = 10000
        val bins = 10
        val binCounts = IntArray(bins)
        val rng = getRng()
        for (i in 1..count) {
            val value = rng.nextDouble()
            assert(value >= 0.0 && value < 1.0)
            binCounts[(value*bins).toInt()]++
        }
        val tol = 4*sqrt(count/bins)
        for (i in 0 until bins) {
            assert(binCounts[i] >= count/bins - tol)
            assert(binCounts[i] <= count/bins + tol)
        }
    }
    
    @Test
    fun testGaussianDistribution() {
        // Compute moments of the distribution.
        
        val count = 10000
        val m = DoubleArray(4)
        val rng = getRng()
        for (i in 1..count) {
            val value = rng.nextGaussian()
            m[0] += value
            m[1] += value*value
            m[2] += value*value*value
            m[3] += value*value*value*value
        }
        for (i in 0..3)
            m[i] = m[i]/count

        // Check the first few cumulants against their expected values.
        
        val c2 = m[1] - m[0]*m[0]
        val c3 = m[2] - 3*m[1]*m[0] + 2*m[0]*m[0]*m[0]
        val c4 = m[3] - 4*m[2]*m[0] - 3*m[1]*m[1] + 12*m[1]*m[0]*m[0] - 6*m[0]*m[0]*m[0]*m[0]
        val tol = 4.0/sqrt(count)
        assert(m[0] >= -tol && m[0] <= tol)
        assert(c2 >= 1.0-tol && c2 <= 1.0+tol)
        assert(c3 >= -5*tol && c3 <= 5*tol)
        assert(c4 >= -5*tol && c4 <= 5*tol)
    }
    
    @Test
    fun testSeed() {
        val rng = KomaRandom(0, 1)
        val values = IntArray(10, { rng.nextInt() })
        
        // If we now set a different seed, we should get different values.
        
        rng.setSeed(1)
        for (i in 0 until values.size)
            assert(rng.nextInt() != values[i])
        
        // Now reset the original seed and verify that it produces the same values.

        rng.setSeed(0)
        for (i in 0 until values.size)
            assert(rng.nextInt() == values[i])
    }
}